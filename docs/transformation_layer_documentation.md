## 6.4 Transformation Layer

The Transformation Layer is a virtual abstraction built on top of the Staging Layer. It is responsible for cleaning, standardizing, and restructuring raw data into a consistent and queryable format, preparing it for loading into the final warehouse dimensions and fact tables. This layer is implemented exclusively using SQL views (`CREATE OR REPLACE VIEW`), ensuring that the raw data in the Staging Layer remains immutable.

### 6.4.1 Virtualization Strategy

Our transformation logic is encapsulated within SQL views prefixed with `staging.clean_*` or `staging.view_clean_*`. This approach constitutes a "Virtual Layer" for the following reasons:

-   **No Data Duplication:** Views are logical constructs, not physical tables. They are queries that run in real-time against the underlying staging tables. This prevents data duplication and eliminates the storage overhead associated with intermediate transformation tables.
-   **Real-Time Transformation:** Any changes or corrections to the transformation logic are reflected instantly upon querying the view. This allows for agile development and rapid iteration without the need for resource-intensive data movement or ETL job reruns at this stage.
-   **Immutability of Staging Data:** By applying transformations through views, we ensure that the raw data ingested into the `staging.stg_*` tables remains an unaltered, auditable source of truth.

### 6.4.2 Data Standardization and Cleansing

The cleaning views perform extensive data standardization to enforce quality and consistency across all datasets. Common techniques observed across the views include:

-   **Whitespace and Case Normalization:**
    -   `TRIM()` is universally applied to identifier columns (`order_id`, `user_id`, `product_id`) to remove leading/trailing whitespace.
    -   `UPPER()` is used on business identifiers like `campaign_id` and `product_id` to enforce a consistent case for joins.
    -   `INITCAP()` is used for proper-noun fields like `name`, `city`, and `street` to standardize capitalization, with additional `REPLACE()` functions to handle specific edge cases (e.g., `O'Malley`).

-   **Handling Nulls and Missing Values:**
    -   `COALESCE()` and `NULLIF()` are used in combination to replace meaningless placeholders (e.g., `'Nan'`, `'', 'Unknown'`) with either a standardized default value (like `'Unknown'`) or a true `NULL`. For example, in `staging.clean_stg_user_data`, `COALESCE(NULLIF(NULLIF(INITCAP(TRIM(name)), 'Nan'), ''), 'Unknown')` ensures a clean `name` value.
    -   Numeric columns, like `discount_value` in `staging.clean_stg_campaign`, use `COALESCE(..., 0.00)` to default null discount values to zero.

-   **Data Type Casting and Formatting:**
    -   `CAST()` is employed to enforce correct data types, such as converting string-based numbers into `INT` or `NUMERIC` types.
    -   `REGEXP_REPLACE()` is frequently used to strip non-numeric characters from fields before casting, as seen in `staging.clean_stg_campaign_transactions` where `REGEXP_REPLACE(estimated_arrival, '[^0-9]', '', 'g')` sanitizes the integer value.

### 6.4.3 Slowly Changing Dimension (SCD) Support

To manage historical data and track changes in dimensional attributes (a Type 2 SCD approach), the Transformation Layer generates two types of hash keys using the `MD5()` function.

-   **Business Key (BK) Generation:**
    A Business Key is a stable, deterministic hash generated from the natural key(s) that uniquely identify a business entity. This key remains constant for that entity throughout its lifecycle. This is primarily handled in the `*_identity_lookup` views. For example, `staging.merchant_identity_lookup` creates the `merchant_bk` by hashing a combination of `merchant_id`, `name`, and `creation_date`. This BK is then propagated to downstream views like `staging.clean_stg_merchant_data`.
    -   **Example (`staging.user_identity_lookup`):**
        ```sql
        MD5(
            LOWER(TRIM(user_id)) || '_' || 
            LOWER(TRIM(name)) || '_' ||    
            COALESCE(TO_CHAR(birthdate, 'YYYY-MM-DD HH24:MI:SS'), '') || '_' ||
            LOWER(TRIM(gender)) || '_' ||
            COALESCE(TO_CHAR(creation_date, 'YYYY-MM-DD HH24:MI:SS'), '')
        ) AS user_bk
        ```

-   **Attribute Hash for Change Detection:**
    An Attribute Hash is generated by hashing the combination of a record's descriptive attributes. This hash is used to detect changes between an incoming record and its existing version in the data warehouse. If the attribute hashes differ for the same Business Key, it signifies that the entity has been updated, and a new SCD Type 2 record should be created.
    -   **Example (`staging.view_clean_product_list`):**
        ```sql
        MD5(
            COALESCE(product_name, '') ||
            COALESCE(product_type, '') ||
            COALESCE(CAST(price AS TEXT), '')
        ) AS product_attribute_hash
        ```
    In this example, the `product_attribute_hash` captures the state of the product's name, type, and price. A change to any of these values will result in a new hash, signaling a change that needs to be tracked.

### 6.4.4 Deterministic Sequencing and Deduplication

The `ROW_NUMBER()` window function is critical for ensuring data integrity and determinism. It is used in two primary patterns:

-   **Deduplication:**
    To handle duplicate records that may be ingested from different source files or at different times, `ROW_NUMBER()` is used to isolate a single, authoritative record. This is typically done by partitioning by the entity's Business Key or natural key and ordering by `ingestion_date DESC`, which selects the most recently ingested version.
    -   **Example (`staging.clean_stg_orders`):**
        ```sql
        ROW_NUMBER() OVER (
            PARTITION BY order_id 
            ORDER BY ingestion_date DESC
        ) AS exact_dup_rank
        -- The view is then filtered WHERE exact_dup_rank = 1
        ```

-   **Positional Ambiguity Resolution:**
    In cases where a natural sequence is missing, such as with line items belonging to an order, `ROW_NUMBER()` generates a deterministic sequence number. To guarantee a stable and repeatable order, the `ORDER BY` clause uses a cascade of columns: `ingestion_date`, `source_filename`, and finally `ctid` (the internal physical tuple location). This ensures that even if two line items were ingested at the exact same time from the same file, their sequence is resolved predictably.
    -   **Example (`staging.view_clean_line_items_prices`):
        ```sql
        ROW_NUMBER() OVER (
            PARTITION BY order_id
            ORDER BY ingestion_date, source_filename, ctid
        ) AS line_item_seq
        ```